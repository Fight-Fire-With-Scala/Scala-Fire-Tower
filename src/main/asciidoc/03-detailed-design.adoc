:pumldir: ./assets/puml

In questa sezione, si mostrano le scelte di design più critiche circa l'organizzazione della struttura del sistema e dei suoi componenti.

== Model

=== GameBoard

[plantuml, format="svg"]
----
include::{pumldir}/GameBoard.puml[]
----
[#game-board-class-diagram]
.Diagramma delle classi che mostra le classi della GameBoard.

La `GameBoard` è la parte cruciale del model dell'applicazione.
Parlerò delle classi principali che lo compongono e del loro ruolo.

- `GameBoard`: Contiene un riferimento alla `Board`, che a sua volta contiene la `Grid` e la direzione del
vento, insieme al mazzo di carte (`Deck`) e ai due giocatori. C'è anche un riferimento al `PlayerManager`,
che consente di gestire il turno dei giocatori.
Infine, contiene il numero del turno e la fase di gioco corrente.
Offre la possibilità di ottenere i giocatori, di gestirli (cambio turno), di determinare se qualche giocatore
ha vinto sull'altro, e di poter risolvere gli effetti di gioco (`IGameEffect`) tramite il metodo solveEffect racchiuso
nel Trait `GameBoardManager`.
- `Board`: Rappresenta la griglia di gioco e la direzione del vento. Offre metodi per verificare se una torre è in
fiamme e per generare configurazioni standard e di fine gioco della griglia.
- `Deck`: Gestisce il mazzo di carte, inclusa la miscelazione, la pesca di carte standard e speciali,
e la rigenerazione del mazzo.
- `Player`: Rappresenta un giocatore nel gioco, con il suo nome, le mosse effettuate, le carte in mano,
una carta extra opzionale e le posizioni delle torri.
- `PlayerToggle`: Gestisce il turno dei giocatori. Ad esempio per cambiare il turno verrà usato il metodo toggle.
- `GamePhase`: Enumera le diverse fasi del gioco, come la fase del vento, la fase di ridistribuzione delle carte,
la fase di gioco delle carte standard, ecc.

Componente fondamentale della `GameBoard` è la `Grid`, che gestisce la griglia di gioco.

[plantuml, format="svg"]
----
include::{pumldir}/Grid.puml[]
----
[#grid-class-diagram]
.Diagramma delle classi che mostra le classi della Grid.

La `Grid` è composta da tre parti fondamentali:

- Il Trait, che definisce l'interfaccia base per la griglia. Contiene i metodi per ottenere e impostare le celle
e i token.
- L'Object, che implementa il Trait `Grid` e offre metodi per creare le istanze, come quella vuota, standard o di fine gioco.
Contiene anche la costante per la dimensione della griglia. Le istanze sono definite in `GridDefinitions`, che contiene
le configurazioni.
- La classe `BasicGrid` è l'implementazione concreta del Trait `Grid` e ne definisce i metodi.

Allo scopo di essere creata la `Grid` utilizza la classe `GridBuilder` che permette di costruire la griglia in modo incrementale.

Attraverso i suoi metodi setNextCell e nextRow (poi utilizzati tramite alias + e -) è possibile procedere alla creazione.
Nell'Object `GridBuilder` vengono forniti dei metodi di configurazione e un DSL per facilitarne la costruzione.
Il DSL tiene conto dei simboli T,F,E per rappresentare i vari tipi di cella (Torre, Foresta e Eternal Fire).

La `Grid` contiene anche la classe `TowerPositionManager`, che permette di ottenere le posizioni delle celle torri basate sulla loro
posizione. Questo è utile per determinare se una torre è in fiamme e per effettuare i calcoli per il Bot.

Le Enumerazioni `Cell` e `ConcreteToken` definiscono rispettivamente :

- `Cell`: Le celle che possono essere posizionate sulla griglia, come la torre, la foresta e il fuoco eterno.
- `ConcreteToken`: I token che possono essere posizionati su una cella, come tagliafuoco, fuoco, acqua, reforest e empty.

I Token vengono definiti in un Trait con un identificativo ed un colore (per la rappresentazione grafica), ma poi utilizzano
la enumerazione che ne estende il Trait per definire i token concreti.

Come anticipato in precedenza, svolge il ruolo di gestione degli effetti di gioco il Trait
`GameBoardManager`.
È infatti responsabile di risolvere i vari tipi di effetti di gioco, che sono:

- `PhaseEffect`
- `HandEffect`
- `PatternEffect`
- `GameBoardEffectSolver`
- `WindUpdateEffect`

Molti di questi solver vengono gestiti in altre parti dell'applicazione, come per la fase,
per la hand, per il pattern e per il wind update.

Una volta risolto l'effetto, il `GameBoardManager` ritorna la `GameBoard` aggiornata.

=== Player

[plantuml, format="svg"]
----
include::{pumldir}/Player.puml[]
----
[#player-class-diagram]
.Diagramma delle classi che mostra le classi del Player.

Per quanto riguarda la modellazione dei giocatori, visto la possibilità di avere un giocatore umano e un giocatore bot, si è deciso di modellare il giocatore come un Trait *Player* che contiene i metodi comuni tra i due tipi di giocatori.
Nello specifico il Trait Player contiene le seguenti informazioni:

- *name*: Il nome del giocatore
- *moves*: La lista delle mosse effettuate dal giocatore
- *hand*: La lista delle carte in mano al giocatore
- *extraCard*: Una carta extra che il giocatore può avere in mano
- *towerPositions*: Un set di posizioni delle proprie torri

Inoltre sono presenti una serie di Option per memorizzare le ultime azioni effettuate dal giocatore.

Il Trait inoltre implementa i metodi comuni tra i due tipi di giocatori come:

- *drawCardFromDeck*: Metodo che permette di pescare una carta dal mazzo ed inserirla nell'apposito slot della mano del giocatore popolando la hand in caso di carte normali o l'extraCard in caso di carte speciali

- *playCard*: Metodo che permette di giocare una carta dalla mano del giocatore e restituisce il giocatore aggiornato e la carta giocata

- *logMove*: Metodo che permette di loggare una mossa effettuata dal giocatore

- *discardCards*: Metodo che permette di scartare una o più carte dalla mano del giocatore

- *updatePlayer* di aggiornare le informazioni del giocatore in base alle mosse effettuate.

Il Trait Player è esteso da tre classi:

- *Person*: Rappresenta un giocatore umano che non presenta particolari comportamenti aggiuntivi

- *Bot* e *ThinkingPlayer*: Che vanno a rappresentare il giocatore bot.

=== Bot

Il Bot oltre a contenere le informazioni del giocatore, contiene un riferimento al *BotBehaviour* che rappresenta il comportamento del bot e un riferimento all'*BotSubject* che rappresenta l'observable del bot utilizzato per interagire con i componenti esterni simulando le azioni gestite tramite gli handler grafici.
Inoltre per reagire ai cambi stato del gioco, viene usato il metodo *think* che permette al bot di effettuare le azioni necessarie per il proprio turno.

Tramite il trait *ThinkingPlayer* vengono implementati i metodi per la gestione delle fasi del turno e delle azioni da compiere in base alla fase del turno.
Più nello specifico vengono implementati i metodi:

- *thinkForWindPhase*: Metodo che permette al bot di piazzare un token fuoco sulla griglia in base alla direzione del vento.

- *thinkForWaitingPhase*: Metodo che permette al bot di decidere se giocare una carta o scartare e pescare

- *thinkForRedrawCardPhase*: Metodo che permette al bot di scartare e pescare fino a 5 carte dalla propria mano

- *thinkForPlayStandardCardPhase*: Metodo che permette al bot di giocare una carta dalla propria mano

- *thinkForDecisionPhase*: Metodo che permette al bot di decidere terminare il turno o giocare una carta speciale

- *thinkForPlaySpecialCardPhase*: Metodo che permette al bot di giocare una carta speciale dalla propria mano

A supporto dei metodi di think, è stato implementato il trait *IMakeDecision* che contiene i metodi per filtrare le carte in base alla decisione e per verificare la presenza di token fuoco o fire break sulla griglia.

Ogni metodo di think presenta un'implementazione specifica per il bot che permette di gestire le azioni in modo automatico.
Nel dettaglio:

=== thinkForWindPhase
Per permettere il piazzamento di un token fuoco sulla griglia in base alla direzione del vento, vengono designate come torri target le due torri avversarie e modellata la direzione del vento riproducendo una carta.
Viene poi lasciata la computazione della posizione del token fuoco alla teoria prolog LogicSolverManager.

=== thinkForWaitingPhase
Per definire se passare alla fase di PlayStandardCard o RedrawCard, vine utilizzata la teoria Prolog AttackDefenseTheory per determinare se passare in fase di attacco o difesa, in base alla decisione presa vengono analizzate le carte presenti in mano e scelte le azioni da compiere.
Se non sono presenti carte che possono essere giocate, il bot passa alla fase di RedrawCard.

=== thinkForRedrawCardPhase
Per scartare e pescare fino a 5 carte dalla propria mano, il bot scarta le carte che non sono utili per la fase di gioco corrente e pesca fino a 5 carte.

=== thinkForPlayStandardCardPhase
Per giocare una carta dalla propria mano, vengono filtrate le carte in base alla decisione presa in fase di Waiting e scomposte in effetti singoli visto che alcune carte possono avere sia effetti difensivi che offensivi.
Una volta ottenuta la mappa dei relativi id carta ed effetto, viene utilizzata la teoria Prolog LogicSolverManager per determinare la carta da giocare e la posizione in cui giocarla.

=== thinkForDecisionPhase
Per decidere se terminare il turno o giocare una carta speciale, il bot verifica la presenza token fuoco nelle porpoise torri.

=== thinkForPlaySpecialCardPhase
Se presente la carta speciale nella mano del bot viene calcolata la posizione in cui piazzarla tramite la teoria Prolog LogicSolverManager.

Ogni metodo di think chiama a sua volta *onUpdateGamePhaseRequest* per notificare la view del cambio di fase e *handleMoveAndApplyEffect* per applicare gli effetti delle mosse.

